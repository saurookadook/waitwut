---
title: 'Domain Driven Design'
date: '2023-01-27'
fullPath: '/notes/domain-driven-design'
sectionSlug: 'notes'
---

# Overview

Planning steps:
- domain model
- code design

## Ubiquitous Language

**Use the model as the backbone of a language.**
- use the language _**consistently**_ in all communications and in code
- make sure this language appears _**consistently**_ in all the communication forms used by the team

### Quotes

### Introduction

> Software has to be practical and useful; otherwise we would not invest so much time and resources into its creation. That makes it extremely connected to a certain aspect of our lives. A useful package of software cannot be decoupled from that sphere of reality, the domain it is supposed to help us manage. On the contrary, the software is deeply entangled with it.
_pg. 1_

#### Ch. 1: What Is Domain-Driven Design

> When we begin a software project, we should focus on the domain it is operating in. The entire purpose of the software is to enhance a specific domain.
> ...
> How can we make the software fit harmoniously with the domain? The best way to do it is to make software a reflection of the domain. Software needs to incorporate the core concepts and elements of the domain, and to precisely realize the relationships between them. Software has to model the domain.
> Somebody without knowledge of banking should be able to learn a lot just by reading the code in a domain model. This is essential.
_pg. 4_

> According to Eric Evans, a domain model is not a particular diagram; it is the idea that the diagram is intended to convey. It is not just the knowledge in a domain expert's head; it is a rigorously organized and selective abstraction of that knowledge. A diagram can represent and communicate a model, as can carefully written code, as can an English sentence.
> ...
> We need to organize information, to systematize it, to divide it up in smaller pieces, to group those pieces into logical modules, and take one at a time and deal with it. We even need to leave some parts of the domain out. A domain contains just too much information to include it all into the model. And much of it is not even necessary to be considered.
_pg. 5_

> We are not alone in this process, so we need to share knowledge and information, and we need to do it well, precisely, completely, and without ambiguity.
_pg. 6_

##### Building Domain Knowledge

> You and the domain experts are talking, you are exchanging knowledge. You start asking questions, and they respond. While they do that, they dig essential concepts out of the air traffic domain. Those concepts may come out unpolished and disorganized, but nonetheless they are essential for understanding the domain. You need to learn as much as possible about the domain from the experts. And by putting the right questions, and processing the information in the right way, you and the experts will start to sketch a view of the domain, a domain model.
_pg. 11_

#### Ch. 2: The Ubiquitous Language

> To overcome this difference in communication style, when we build the model, we must communicate to exchange ideas about the model, about the elements involved in the model, how we connect them, what is relevant and what is not. Communication at this level is paramount for the success of the project. If one says something, and the other does not understand or, even worse, understands something else, what are the chances for the project to succeed?

_pg. 14_

> A core principle of domain-driven design is to use a language based on the model. Since the model is the common ground, the place where the software meets the domain, it is appropriate to use it as the building ground for this language.

> Use the model as the backbone of a language. Request that the team use the language consistently in all communications, and also in the code. While sharing knowledge and hammering out the model, the team uses speech, writing and diagrams. Make sure this language appears consistently in all the communication forms used by the team; for this reason, the language is called the Ubiquitous Language.

> Languages do not appear overnight. It takes hard work and a lot of focus to make sure that the key elements of the language are brought to light.

> Building a language like that has a clear outcome: the model and the language are strongly interconnected with one another. A change in the language should become a change to the model.

_pg. 15_

> However, in real life such a dialog is much more verbose, and people very often talk about things indirectly, or enter into too much detail, or choose the wrong concepts; this can make coming up with the language very difficult. To begin to address this, all team members should be aware of the need to create a common language and should be reminded to stay focused on essentials, and use the language whenever necessary. We should use our own jargon during such sessions as little as possible, and we should use the Ubiquitous Language because this helps us communicate clearly and precisely.

_pg. 18_

### References

- [Domain-Driven Design Quickly](https://www.infoq.com/minibooks/domain-driven-design-quickly/)
