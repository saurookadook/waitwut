---
title: "Python"
date: "2022-07-23"
fullPath: "/sheets/python"
iconComponentName: "python_icon"
sectionSlug: "sheets"
---

# Table of Contents
- [General](#general)
- [Scalar Types](/scalar-types)
- [Control Flow](/control-flow)
- [Tools](/tools)
- [Numeric Types](/numeric-types)
- [tuples](/tuples)
- [lists](/lists)
- [dicts](/dicts)
- [Modules](/modules)
- [Statements](#statements)
- [Conditionals](#conditionals)
- [Lambdas](#lambdas)
- [Those other things that are good to know](#those-other-things-that-are-good-to-know)
- [Functions](#functions)
- [Closures](#closures)
- [decorators](#decorators)
- [Strings and Representations](#strings-and-representations)

---

## General

### Significant Whitespace

- Python uses whitespace to demarcate code blocks
- by convention, 4 spaces are used per depth
- end blocks with blank lines(?)

#### Significant Whitespace Rules

1. Prefer four spaces
2. NEVER mix spaces and tabs
3. Be consistent on consecutive lines
4. Only deviate to improve readability


_"Programming as Guido ~~intended~~ indented it"_

### Python Culture

[Python Enhancement Proposals (pep)](https://peps.python.org/)

#### Pep 20: The Zen of Python

```python
import this
```
### The Python Standard Library

- often referred to as "Batteries Included"
- gain access to standard library modules using `import` keyword
- `import module_name`

```python
import math

math.sqrt(81)
# => 9.0
math.factorial(5)
# => 120

n = 5
k = 3

math.factorial(n) / (math.factorial(k) * math.factorial(n - k))
10.0
```

- can use `help` in REPL environment to retrieve any embedded documentation from objects
    - _for example:_ `help(math)`, `help(math.factorial)`

#### Typical uses of `import`

```python
n = 5
k = 3

# simplest import
import math

math.factorial(n) / (math.factorial(k) * math.factorial(n - k))
# => 10.0


# can import specific function from module into namespace
from math import factorial

factorial(n) / (factorial(k) * factorial(n - k))
# => 10.0


# can rename imported function as well
from math import factorial as fac

fac(n) / (fac(k) * fac(n - k))
# => 10.0
```
_NOTE: can return integer using Python's integer division operator_

```py
from math import factorial as fac

n = 5
k = 3

fac(n) // (fac(k) * fac(n - k))
# => 10
```
_NOTE: Python can compute arbitrarily large numbers, limited only by the memory in your computer_

## Relational Operators

- `==`: value equality/equivalence
- `!=`: value inequality/inequivalence
- `<`: less-than
- `>`: greater-than
- `<=`: less-than or equal
- `>=`: greater-than or equal

---

## Statements

`assert`
- [The `assert` Statement](https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement)
- [assert (The Right Way)](https://python-reference.readthedocs.io/en/latest/docs/statements/assert.html)
- [Python `assert` Statement](https://realpython.com/python-assert-statement/)

```python
assert expression

# equivalent to
if __debug__:
    if not expression: raise AssertionError

assert expression, other_expression

# equivalent to
if __debug__:
    if not expression: raise AssertionError(other_expression)



```


---

## Conditionals

### Conditional statement

```python
if condition:
    result = true_value
else:
    result = false_value
```

### Conditional expression

```python
result = true_value if condition else false_value
```

---

## Lambdas

- named after lambda calculus, developed by Alonzo Church in 1936

```python
scientists = [
    'Marie Curie',
    'Albert Einstein',
    'Niels Bohr',
    'Isaac Newton',
    'Dmitri Mendeleev',
    'Antoine Lavoisier',
    'Carl Linnaeus',
    'Alfred Wegener',
    'Charles Darwin'
]

sorted(scientists, key=lambda scientist_name: scientist_name.split()[-1])
```

![`function` vs `lambda`](../src/images/python/function-vs-lambda.png)

---

## Those other things that are good to know
- `==` tests "value equality"
- `is` tests "identity equality"

## Functions

### Detecting callable objects:
```python
def is_even(x):
    return x % 2 == 0

callable(is_even)
#=> True
```

### Making instances of classes callable(?)
```python
class CallMe:
    def __call__(self):
        print("Called!")

call_me = CallMe()
callable(call_me)
#=> True
```

### Extended formal argument syntax

```python
def extended(*args, **kwargs):
```

1. 'star args' _must_ come before 'k w args'
2. any arguments preceding 'star args' will be considered positional arguments
3. any arguments after 'star args' will be mandatory keyword arguments
4. if 'k w args' is present, it _must_ be last in arguments list

#### 'star args'
- handles positional arguments

```python
def hypervolume(*lengths):
    print(f"lengths: {lengths}")
    print(f"type: {type(lengths)}")

    i = iter(lengths)
    v = next(i)
    for length in i:
        v *= length
    return v

### or better yet, making sure a meaningful
# exception gets thrown if called without arguments
def hypervolume(length, *lengths):
    print(f"lengths: {lengths}")
    print(f"type: {type(lengths)}")

    v = length
    for item in lengths:
        v *= item
    return v

```

#### 'k w args' (KWARGS)
- handles keyword arguments
- keyword args passed to `kwargs` as dictionary

```python
def example(name, **kwargs):
    print(f"name: {name}")
    print("kwargs: ")
    print(kwargs)
    print(f"type of kwargs: {type(kwargs)}")


def tag(name, **attributes):
    result = '<' + name
    for key, value in attributes.items():
        result += ' {k}="{v}"'.format(k=key, v=str(value))
    result += '/>'
    return result

```

### Extended actual argument syntax

#### 'star args'

```python
def print_args(arg1, arg2, *args):
    print(arg1)
    print(arg2)
    print(arg3)

t = (11, 12, 13, 14)
print(*t)
#=> 11
#=> 12
#=> (13, 14)
```

#### 'k w args'

```python
def color(red, green, blue, **kwargs):
    print("r = ", red)
    print("g = ", green)
    print("b = ", blue)
    print(kwargs)

k = {'red': 21, 'green': 68, 'blue': 120, 'alpha': 52}
color(**k)
#=> r = 21
#=> g = 68
#=> b = 120
#=> {'alpha': 52}
```

### Forwarding Arguments using `*args` and `**kwargs`

```python
def trace(f, *args, **kwargs):
    print("args = ", args)
    print("kwargs = ", kwargs)
    result = f(*args, **kwargs)
    print("result = ", result)
    return result
```

### Example using `zip()`

```python
sunday = [2, 3, 4, 5, 6]
monday =[11, 12, 13, 14, 15]
tuesday = [5, 4, 3, 2, 1]
daily = [sunday, monday, tuesday]

### all do the same thing
for item in zip(sunday, monday, tuesday):
    print(item)

for item in zip(daily[0], daily[1], daily[2]):
    print(item)

for item in zip(*daily):
    print(item)

### result from `print` in `for` loop as single data structure
transposed = list(zip(*daily)) #=> list of tuples
```

### Local Functions

- generally refers to functions defined inside of other functions

```python
def func():
    def local_func():
        a = 'hello'
        b = 'world'
        return a + b

    x = 1
    y = 2
    return x + y
```

### Returning Function from Function

```python
def outer():
    def inner():
        print('inner')
    return inner

example = outer()
example()
#=> inner
```

### First-class Functions
- functions can be treated like any other object

## Closures
- formed by local functions
- maintain references to objects from earlier scopes
- implemented in Python with special attribute `__closure__`

```python
def enclosing():
    x = 'closed over'
    def local_func():
        print(x)
    return local_func

lf = enclosing()
lf()
#=> closed over
lf.__closure__
#=> (<cell at 0x10ea95cc8: str object at 0x10eac19f0>,)
```

### Function Factory
- function that returns new, specialized functions
- simple example
```python
def raise_to(exp):
    def raise_to_exp(x):
        return pow(x, exp)
    return raise_to_exp

```

### The `nonlocal` Keyword
- LEGB does not apply when making new bindings
- `nonlocal` keyword introduces names from enclosing namespace into local namespace
    - **IMPORTANT**: using `nonlocal` with a name that doesn't exist will result in error

```python
message = 'global'

def enclosing():
    message = 'enclosing'

    def local():
        # does not affect `global` or `enclosing` bindings
        message = 'local'

    print('enclosing message before `local()` call: ', message)
    local()
    print('enclosing message after `local()` call: ', message)

print('global message before `enclosing()` call: ', message)
enclosing()
print('global message after `enclosing()` call: ', message)

#=> global message before `enclosing()` call: global
#=> enclosing message before `local()` call: enclosing
#=> enclosing message after `local()` call: enclosing
#=> global message after `enclosing()` call: global
```

#### Changing `local` binding using `global` keyword
```python
message = 'global'

def enclosing():
    message = 'enclosing'

    def local():
        global message
        message = 'local'

    print('enclosing message before `local()` call: ', message)
    local()
    print('enclosing message after `local()` call: ', message)

print('enclosing message before `enclosing()` call: ', message)
enclosing()
print('enclosing message after `enclosing()` call: ', message)

#=> global message before `enclosing()` call: global
#=> enclosing message before `local()` call: enclosing
#=> enclosing message after `local()` call: enclosing
#=> global message after `enclosing()` call: local
```

#### Changing `local` binding using `nonlocal` keyword
```python
message = 'global'

def enclosing():
    message = 'enclosing'

    def local():
        nonlocal message
        message = 'local'

    print('enclosing message before `local()` call: ', message)
    local()
    print('enclosing message after `local()` call: ', message)

print('enclosing message before `enclosing()` call: ', message)
enclosing()
print('enclosing message after `enclosing()` call: ', message)

#=> global message before `enclosing()` call: global
#=> enclosing message before `local()` call: enclosing
#=> enclosing message after `local()` call: local
#=> global message after `enclosing()` call: global
```

#### Practical Example
```python
# make_timer.py
import time


def make_timer():
    last_called = None

    def elapsed():
        nonlocal last_called
        now = time.time()
        if last_called is None:
            last_called = now
            return None
        result = now - last_called
        last_called = now
        return result

    return elapsed

```

## decorators
- modify or enhance functions without changing their definition
    - aka, non-intrusive and maintainable
- implemented as callables that take and return other callables
- how they work:
    - Python takes decorated function and creates new function object
    - that function object is then passed to decorator function
    - return value from decorator function is then bound to the name of the original function

### Basic Syntax
```python
@my_decorator
def my_function():
    pass
```

### First Decorator Example

Consider: for whatever reason, you need to ensure that these functions return strings which only contain ASCII characters
```python
# translated_words.py
def vegetable():
    return 'blomkål'

def animal():
    return 'bjørn'

def mineral():
    return 'stål'
```

Solution 1: wrap strings in `ascii()`
- not scalable
- not maintainable
```python
# translated_words.py
def vegetable():
    return ascii('blomkål')

def animal():
    return ascii('bjørn')

def mineral():
    return ascii('stål')
```

Solution 2: using `escape_unicode` decorator
```python
# escape_unicode.py
def escape_unicode(f):
    def wrap(*args, **kwargs):
        x = f(*args, **kwargs)
        return ascii(x)

    return wrap

# translated_words.py
from escape_unicode import escape_unicode

@escape_unicode
def vegetable():
    return ascii('blomkål')

@escape_unicode
def animal():
    return ascii('bjørn')

@escape_unicode
def mineral():
    return ascii('stål')

vegetable()
#=> 'blomk\\xe5l'
animal()
#=> 'bj\\xf8rn'
mineral()
#=> 'st\\xe5l'
```

### Other Objects as Decorators

#### Classes as Decorators
```python
class MyDec:
    def __init__(self, f):
        pass

    # NOTE: MUST implement this method in order for instance to be callable
    def __call__(self):
        pass

@MyDec
def func():
    pass
```

Example:
```python
class CallCount:
    def __init__(self, f):
        self.f = f
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1
        return self.f(*args, **kwargs)


@CallCount
def hello(name):
    print('Hello, {}'.format(name))


# in REPL
>>> from call_count import hello
>>> hello('Fred')
#=> Hello, Fred
>>> hello('Wilma')
#=> Hello, Wilma
>>> hello('Betty')
#=> Hello, Betty
>>> hello('Barney')
#=> Hello, Barney
>>> hello.count
#=> 4
```

#### Instances as Decorators

```python
class AnotherDec:
    def __call__(self, f):
        def wrap():
            pass
        return wrap


@AnotherDec()
def func():
    pass
```

Example:
```python
# tracer.py
class Trace:
    def __init__(self):
        self.enabled = True

    def __call__(self, f):
        def wrap(*args, **kwargs):
            if self.enabled:
                print('Calling {}'.format(f))
            return f(*args)


tracer = Trace()

@tracer
def rotate_list(l):
    return l[1:] + [l[0]]


# in REPL
>>> from tracer import rotate_list, tracer
>>> l = [1, 2, 3]
>>> l = rotate_list(l)
#=> Calling <function rotate_list at 0x103a70dd0>
>>> l
#=> [2, 3, 1]
>>> l = rotate_list(l)
#=> Calling <function rotate_list at 0x103a70dd0>
>>> l
#=> [3, 1, 2]
>>> tracer.enabled = False
>>> l = rotate_list(l)
#=>

```

### Multiple Decorators
- simply declare decorators above function with each decorator on a new line
- processed in reverse order

```python
@decorator1
@decorator2
@decorator3
def some_function():
    pass
```

### Decorating Methods

```python
from escape_unicode import escape_unicode # from escape_unicode.py

class Trace:
    def __init__(self):
        self.enabled = True

    def __call__(self, f):
        def wrap(*args, **kwargs):
            if self.enabled:
                print('Calling {}'.format(f))
            return f(*args)


tracer = Trace()

@tracer
@escape_unicode
def norwegian_island_maker(name):
    return name + 'øy'


class IslandMaker:
    def __init__(self, suffix):
        self.suffix = suffix

    @tracer
    def make_island(self, name):
        return name + self.suffix

```

### `functools.wrap()`

- properly updates metadata on wrapped functions
- **problem:** naive decorators can lose important metadata

#### Initial:
```python
# no_op.py
def hello():
    """Print a well-known message."""
    print('Hello, world!')

# in repl
>>> from no_op import hello
>>> hello.__name__
#=> 'hello'
>>> hello.__doc__
#=> 'Print a well-known message.'
>>> help(hello)
#=> Help on function hello in module no_op:
#=>
#=> hello()
#=>     Print a well-known message.
```

#### After adding decorator:
```python
# no_op.py
def no_op(f):
    def no_op_wrapper():
        return f()
    return no_op_wrapper

@no_op
def hello():
    """Print a well-known message."""
    print('Hello, world!')

# in repl
>>> from no_op import hello
>>> help(hello)
#=> Help on function no_op_wrapper in module no_op:
#=>
#=> no_op_wrapper()
>>> hello.__name__
#=> 'no_op_wrapper'
>>> hello.__doc__
#=>
```

#### After fixing decorator:
```python
# no_op.py
def no_op(f):
    def no_op_wrapper():
        return f()

    no_op_wrapper.__name__ = f.__name__
    no_op_wrapper.__doc__ = f.__doc__
    return no_op_wrapper

@no_op
def hello():
    """Print a well-known message."""
    print('Hello, world!')

# in repl
>>> from no_op import hello
>>> help(hello)
#=> Help on function hello in module no_op:
#=>
#=> hello()
#=>     Print a well-known message.
>>> hello.__name__
#=> 'hello'
>>> hello.__doc__
#=> 'Print a well-known message.'
```

#### After fixing decorator with `functools.wrap()`:
```python
# no_op.py
import functools

def no_op(f):
    @functools.wrap(f)
    def no_op_wrapper():
        return f()
    return no_op_wrapper

@no_op
def hello():
    """Print a well-known message."""
    print('Hello, world!')

# in repl
>>> from no_op import hello
>>> help(hello)
#=> Help on function hello in module no_op:
#=>
#=> hello()
#=>     Print a well-known message.
>>> hello.__name__
#=> 'hello'
>>> hello.__doc__
#=> 'Print a well-known message.'
```

### Decorators as argument validators

```python
# create_list.py
def check_non_negative(index):
    def validator(f):
        def wrap(*args):
            if args[index] < 0:
                raise ValueError(
                    'Argument {} must be non-negative'.format(index)
                )
            return f(*args)
        return wrap
    return validator

@check_non_negative(1)
def create_list(value, size):
    return [value] * size

```

---

## Properties and Class Methods

<details>

<summary>Code example</summary>

<span>

```python
class ShippingContainer:

    def __init__(self, owner_code, contents):
        self.owner_code = owner_code
        self.contents = contents

```

</span>
</details>

### Class Attributes

Class attributes created within scope of class

<details>

<summary>Code example</summary>

<span>

```python
class ShippingContainer:

    next_serial = 1337  # lolz

    def __init__(self, owner_code, contents):
        self.owner_code = owner_code
        self.contents = contents
        self.serial = ShippingContainer.next_serial
        ShippingContainer.next_serial += 1

```

</span>
</details>

**NOTE**: assignment via `self.attr = something` _always_ creates instance attribute

### Static Methods

- created with use of `@staticmethod` decorator

<details>

<summary>Code example</summary>

<span>

```python
class ShippingContainer:

    next_serial = 1337  # lolz

    @staticmethod
    def _get_next_serial():
        result = ShippingContainer.next_serial
        ShippingContainer.next_serial += 1
        return result

    def __init__(self, owner_code, contents):
        self.owner_code = owner_code
        self.contents = contents
        self.serial = ShippingContainer._get_next_serial()

```

</span>
</details>

### Class Methods

- created with use of `@classmethod` decorator

<details>

<summary>Code example</summary>

<span>

```python
class ShippingContainer:

    next_serial = 1337  # lolz

    @classmethod
    def _get_next_serial(cls):
        result = cls.next_serial
        cls.next_serial += 1
        return result

    def __init__(self, owner_code, contents):
        self.owner_code = owner_code
        self.contents = contents
        self.serial = ShippingContainer._get_next_serial()

```

</span>
</details>

#### Class Methods for Named Constructors

- "named constructors" also known as "factory functions"
    - construct objects with certain configurations
    - allows support for multiple functions which behave similarly to constructors but:
        - with different behaviors
        - without needing to change `__init__` to handle different forms of argument lists

<details>

<summary>Code example</summary>

<span>

```python
class ShippingContainer:

    next_serial = 1337  # lolz

    @classmethod
    def _get_next_serial(cls):
        result = cls.next_serial
        cls.next_serial += 1
        return result

    @classmethod
    def create_empty(cls, owner_code):
        return cls(owner_code, contents=None)

    @classmethod
    def create_with_items(cls, owner_code, items):
        return cls(owner_code, contents=list(items))

    def __init__(self, owner_code, contents):
        self.owner_code = owner_code
        self.contents = contents
        self.serial = ShippingContainer._get_next_serial()

```

</span>
</details>

##### _Aside - ISO 6346 BIC code_
- _BIC === Bureau International des Containers (International Container Bureau)_
- _Full example: **CSQU3054383**_
_consists of:_
    - _owner code (**CSQ**)_
    - _category identifier (**U**)_
    - _serial number (**305438**)_
    - _check digit (**3**)_

<details>

<summary>

_Provided helper module_

</summary>

<span>

```python
"""
ISO 6346 shipping container codes.
"""


def create(owner_code, serial, category='U'):
    """Create an ISO 6346 shipping container code.

    Args:
        owner_code (str): Three character alphabetic container code.
        serial (str): Six digit numeric serial number.
        category (str): Equipment category identifier.

    Returns:
        An ISO 6346 container code including a check digit.

    Raises:
        ValueError: If incorrect values are provided.
    """
    if not (len(owner_code) == 3 and owner_code.isalpha()):
        raise ValueError("Invalid ISO 6346 owner code '{}'".format(owner_code))

    if category not in ('U', 'J', 'Z', 'R'):
        raise ValueError("Invalid ISO 6346 category identifier '{}'".format(category))

    if not (len(serial) == 6 and serial.isdigit()):
        raise ValueError("Invalid ISO 6346 serial number")

    raw_code = owner_code + category + serial
    full_code = raw_code + str(check_digit(raw_code))
    return full_code


def check_digit(raw_code):
    """Compute the check digit for an ISO 6346 code without that digit

    Args:
        raw_code (str): An ISO 6346 code lacking a check digit.

    Returns:
        An integer check digit between 0 and 9 inclusive.
    """
    s = sum(code(char) * 2**index for index, char in enumerate(raw_code))
    return s % 11 % 10


def code(char):
    """Determine the ISO 6346 numeric equivalent of a character.

    Args:
        char (str): A single character string.

    Return:
        An integer code equivalent to the supplied character.
    """
    return int(char) if char.isdigit() else letter_code(char)


def letter_code(letter):
    """Determine the ISO 6346 numeric code for a letter.

    Args:
        letter (str): A single letter.

    Returns:
        An integer character code equivalent to the supplied letter.
    """
    value = ord(letter.lower()) - ord('a') + 10
    return value + value // 11

```

</span>
</details>

#### Static Method Example Using BIC Code Helper

<details>

<summary>Code example</summary>

<span>

```python
import iso6346


class ShippingContainer:

    next_serial = 1337  # lolz

    @staticmethod
    def _make_bic_code(owner_code, serial):
        return iso6346.create(
            owner_code=owner_code,
            serial=str(serial).zfill(6)
        )

    @classmethod
    def _get_next_serial(cls):
        result = cls.next_serial
        cls.next_serial += 1
        return result

    @classmethod
    def create_empty(cls, owner_code):
        return cls(owner_code, contents=None)

    @classmethod
    def create_with_items(cls, owner_code, items):
        return cls(owner_code, contents=list(items))

    def __init__(self, owner_code, contents):
        self.contents = contents
        self.bic = ShippingContainer._make_bic_code(
            owner_code=owner_code,
            serial=ShippingContainer._get_next_serial()
        )

```

</span>
</details>

### Static Methods with Inheritance

- in Python, static methods can be overridden in subclasses

<details>

<summary>Code example</summary>

<span>

```python
import iso6346


class ShippingContainer:

    next_serial = 1337  # lolz

    @staticmethod
    def _make_bic_code(owner_code, serial):
        return iso6346.create(
            owner_code=owner_code,
            serial=str(serial).zfill(6)
        )

    @classmethod
    def _get_next_serial(cls):
        result = cls.next_serial
        cls.next_serial += 1
        return result

    @classmethod
    def create_empty(cls, owner_code):
        return cls(owner_code, contents=None)

    @classmethod
    def create_with_items(cls, owner_code, items):
        return cls(owner_code, contents=list(items))

    def __init__(self, owner_code, contents):
        self.contents = contents
        self.bic = self._make_bic_code(  # need to reference 'self' instead so that the overriden method is called instead of the method from the base class
            owner_code=owner_code,
            serial=ShippingContainer._get_next_serial()
        )


class RefrigeratedShippingContainer(ShippingContainer):

    @staticmethod
    def _make_bic_code(owner_code, serial):
        return iso6346.create(
            owner_code=owner_code,
            serial=str(serial).zfill(6),
            category='R'
        )
```

</span>
</details>

### Class Methods with Inheritance

- distinguishing feature of Python is ability to have class methods behave polymorphically

<details>

<summary>Code example</summary>

<span>

```python
import iso6346


class ShippingContainer:

    next_serial = 1337  # lolz

    @staticmethod
    def _make_bic_code(owner_code, serial):
        return iso6346.create(
            owner_code=owner_code,
            serial=str(serial).zfill(6)
        )

    @classmethod
    def _get_next_serial(cls):
        result = cls.next_serial
        cls.next_serial += 1
        return result

    # NOTE: added *args and **kwargs to accomodate use of these methods in derived subclasses
    @classmethod
    def create_empty(cls, owner_code, *args, **kwargs):
        return cls(owner_code, contents=None, *args, **kwargs)

    @classmethod
    def create_with_items(cls, owner_code, items, *args, **kwargs):
        return cls(owner_code, contents=list(items), *args, **kwargs)

    def __init__(self, owner_code, contents):
        self.contents = contents
        self.bic = self._make_bic_code(
            owner_code=owner_code,
            serial=ShippingContainer._get_next_serial()
        )


class RefrigeratedShippingContainer(ShippingContainer):

    MAX_CELSIUS = 4.0

    @staticmethod
    def _make_bic_code(owner_code, serial):
        return iso6346.create(
            owner_code=owner_code,
            serial=str(serial).zfill(6),
            category='R'
        )

    def __init__(self, owner_code, contents, celsius):
        super().__init__(owner_code, contents)

        if celsius > RefrigeratedShippingContainer.MAX_CELSIUS:
            raise ValueError("Temperature too hot!")
        self.celsius = celsius

```

</span>
</details>

### Properties

- encapsulation using the `@property` decorator
[Property Decorator Diagram](/src/images/python/property-decorator-diagram.png)

<details>

<summary>Code example</summary>

<span>

```python
import iso6346


class ShippingContainer:

    next_serial = 1337  # lolz

    @staticmethod
    def _make_bic_code(owner_code, serial):
        return iso6346.create(
            owner_code=owner_code,
            serial=str(serial).zfill(6)
        )

    @classmethod
    def _get_next_serial(cls):
        result = cls.next_serial
        cls.next_serial += 1
        return result

    @classmethod
    def create_empty(cls, owner_code, *args, **kwargs):
        return cls(owner_code, contents=None, *args, **kwargs)

    @classmethod
    def create_with_items(cls, owner_code, items, *args, **kwargs):
        return cls(owner_code, contents=list(items), *args, **kwargs)

    def __init__(self, owner_code, contents):
        self.contents = contents
        self.bic = self._make_bic_code(
            owner_code=owner_code,
            serial=ShippingContainer._get_next_serial()
        )


class RefrigeratedShippingContainer(ShippingContainer):

    MAX_CELSIUS = 4.0

    @staticmethod
    def _make_bic_code(owner_code, serial):
        return iso6346.create(
            owner_code=owner_code,
            serial=str(serial).zfill(6),
            category='R'
        )

    def __init__(self, owner_code, contents, celsius):
        super().__init__(owner_code, contents)

        if celsius > RefrigeratedShippingContainer.MAX_CELSIUS:
            raise ValueError("Temperature too hot!")
        self._celsius = celsius

    @property  # celsius getter
    def celsius(self):
        return self._celsius

    @celsius.setter
    def celsius(self, value):
        if value > RefrigeratedShippingContainer.MAX_CELSIUS:
            raise ValueError("Temperature too hot!")
        self._celsius = value

```

</span>
</details>

<details>

<summary>Extended example</summary>

<span>

```python
import iso6346


class ShippingContainer:

    next_serial = 1337  # lolz

    @staticmethod
    def _make_bic_code(owner_code, serial):
        return iso6346.create(
            owner_code=owner_code,
            serial=str(serial).zfill(6)
        )

    @classmethod
    def _get_next_serial(cls):
        result = cls.next_serial
        cls.next_serial += 1
        return result

    @classmethod
    def create_empty(cls, owner_code, *args, **kwargs):
        return cls(owner_code, contents=None, *args, **kwargs)

    @classmethod
    def create_with_items(cls, owner_code, items, *args, **kwargs):
        return cls(owner_code, contents=list(items), *args, **kwargs)

    def __init__(self, owner_code, contents):
        self.contents = contents
        self.bic = self._make_bic_code(
            owner_code=owner_code,
            serial=ShippingContainer._get_next_serial()
        )


class RefrigeratedShippingContainer(ShippingContainer):

    MAX_CELSIUS = 4.0

    @staticmethod
    def _make_bic_code(owner_code, serial):
        return iso6346.create(
            owner_code=owner_code,
            serial=str(serial).zfill(6),
            category='R'
        )

    @staticmethod
    def _c_to_f(celsius):
        return celsius * 9/5 + 32

    @staticmethod
    def _f_to_c(fahrenheit):
        return (fahrenheit - 32) * 5/9

    def __init__(self, owner_code, contents, celsius):
        super().__init__(owner_code, contents)
        self.celsius = celsius

    @property
    def celsius(self):
        return self._celsius

    @celsius.setter
    def celsius(self, value):
        if value > RefrigeratedShippingContainer.MAX_CELSIUS:
            raise ValueError("Temperature too hot!")
        self._celsius = value

    @property
    def fahrenheit(self):
        return RefrigeratedShippingContainer._c_to_f(self.celsius)

    @fahrenheit.setter
    def fahrenheit(self, value):
        self.celsius = RefrigeratedShippingContainer._f_to_c(value)

```

</span>
</details>

### Properties and Inheritance

- inheritance interaction with the `@property` decorator

<details>

<summary>Code example</summary>

<span>

```python
import iso6346


class ShippingContainer:

    HEIGHT_FT = 8.5
    WIDTH_FT = 8.0
    next_serial = 1337

    @staticmethod
    def _make_bic_code(owner_code, serial):
        return iso6346.create(
            owner_code=owner_code,
            serial=str(serial).zfill(6)
        )

    @classmethod
    def _get_next_serial(cls):
        result = cls.next_serial
        cls.next_serial += 1
        return result

    @classmethod
    def create_empty(cls, owner_code, length_ft *args, **kwargs):
        return cls(owner_code, length_ft, contents=None, *args, **kwargs)

    @classmethod
    def create_with_items(cls, owner_code, length_ft items, *args, **kwargs):
        return cls(owner_code, length_ft, contents=list(items), *args, **kwargs)

    def __init__(self, owner_code, length_ft, contents):
        self.contents = contents
        self.length_ft = length_ft
        self.bic = self._make_bic_code(
            owner_code=owner_code,
            serial=ShippingContainer._get_next_serial()
        )

    @property
    def volume_in_cubic_feet(self):
        return ShippingContainer.HEIGHT_FT * ShippingContainer.WIDTH_FT * self.length_ft


class RefrigeratedShippingContainer(ShippingContainer):

    MAX_CELSIUS = 4.0

    FRIDGE_VOLUME_IN_CUBIC_FEET = 100

    @staticmethod
    def _make_bic_code(owner_code, serial):
        return iso6346.create(
            owner_code=owner_code,
            serial=str(serial).zfill(6),
            category='R'
        )

    @staticmethod
    def _c_to_f(celsius):
        return celsius * 9/5 + 32

    @staticmethod
    def _f_to_c(fahrenheit):
        return (fahrenheit - 32) * 5/9

    def __init__(self, owner_code, length_ft, contents, celsius):
        super().__init__(owner_code, length_ft, contents)
        self.celsius = celsius

    @property
    def celsius(self):
        return self._celsius

    @celsius.setter
    def celsius(self, value):
        if value > RefrigeratedShippingContainer.MAX_CELSIUS:
            raise ValueError("Temperature too hot!")
        self._celsius = value

    @property
    def fahrenheit(self):
        return RefrigeratedShippingContainer._c_to_f(self.celsius)

    @fahrenheit.setter
    def fahrenheit(self, value):
        self.celsius = RefrigeratedShippingContainer._f_to_c(value)

    @property
    def volume_in_cubic_feet(self):
        return super().volume_in_cubic_feet - RefrigeratedShippingContainer.FRIDGE_VOLUME_IN_CUBIC_FEET

```

</span>
</details>

<details>

<summary>Extended example (overriding setter)</summary>

<span>

```python
import iso6346


class ShippingContainer:

    HEIGHT_FT = 8.5
    WIDTH_FT = 8.0
    next_serial = 1337

    @staticmethod
    def _make_bic_code(owner_code, serial):
        return iso6346.create(
            owner_code=owner_code,
            serial=str(serial).zfill(6)
        )

    @classmethod
    def _get_next_serial(cls):
        result = cls.next_serial
        cls.next_serial += 1
        return result

    @classmethod
    def create_empty(cls, owner_code, length_ft *args, **kwargs):
        return cls(owner_code, length_ft, contents=None, *args, **kwargs)

    @classmethod
    def create_with_items(cls, owner_code, length_ft items, *args, **kwargs):
        return cls(owner_code, length_ft, contents=list(items), *args, **kwargs)

    def __init__(self, owner_code, length_ft, contents):
        self.contents = contents
        self.length_ft = length_ft
        self.bic = self._make_bic_code(
            owner_code=owner_code,
            serial=ShippingContainer._get_next_serial()
        )

    @property
    def volume_in_cubic_feet(self):
        return ShippingContainer.HEIGHT_FT * ShippingContainer.WIDTH_FT * self.length_ft


class RefrigeratedShippingContainer(ShippingContainer):

    MAX_CELSIUS = 4.0

    FRIDGE_VOLUME_IN_CUBIC_FEET = 100

    @staticmethod
    def _make_bic_code(owner_code, serial):
        return iso6346.create(
            owner_code=owner_code,
            serial=str(serial).zfill(6),
            category='R'
        )

    @staticmethod
    def _c_to_f(celsius):
        return celsius * 9/5 + 32

    @staticmethod
    def _f_to_c(fahrenheit):
        return (fahrenheit - 32) * 5/9

    def __init__(self, owner_code, length_ft, contents, celsius):
        super().__init__(owner_code, length_ft, contents)
        self.celsius = celsius

    @property
    def celsius(self):
        return self._celsius

    @celsius.setter
    def celsius(self, value):
        if value > RefrigeratedShippingContainer.MAX_CELSIUS:
            raise ValueError(f"Temperature of {value} is too hot!")
        self._celsius = value

    @property
    def fahrenheit(self):
        return RefrigeratedShippingContainer._c_to_f(self.celsius)

    @fahrenheit.setter
    def fahrenheit(self, value):
        self.celsius = RefrigeratedShippingContainer._f_to_c(value)

    @property
    def volume_in_cubic_feet(self):
        return super().volume_in_cubic_feet - RefrigeratedShippingContainer.FRIDGE_VOLUME_IN_CUBIC_FEET


class HeatedRefrigeratedShippingContainer(RefrigeratedShippingContainer):

    MIN_CELSIUS = -20.0

    @RefrigeratedShippingContainer.celsius.setter
    def celsius(self, value):
        if not (HeatedRefrigeratedShippingContainer.MIN_CELSIUS
                <= value
                <= RefrigeratedShippingContainer.MAX_CELSIUS):
            raise ValueError(f"Temperature {value} is out of range!")
        self._celsius = value

```

</span>
</details>

_Aside - chained relational operators_

Python allows for chaining relational operators, so that one can write `a < b < c` in place of `(a < b) and (b < c)`

<details>

<summary>Example with pitfalls</summary>

<span>

```python

class HeatedRefrigeratedShippingContainer(RefrigeratedShippingContainer):

    MIN_CELSIUS = -20.0

    # NOTE: this doesn't work
    @RefrigeratedShippingContainer.celsius.setter
    def celsius(self, value):
        if value < HeatedRefrigeratedShippingContainer.MIN_CELSIUS:
            raise ValueError(f"Temperature {value} is out of range!")
        super().celsius = value  # throws AttributeError: 'super' object has no attribute 'celsius'

    # This works
    @RefrigeratedShippingContainer.celsius.setter
    def celsius(self, value):
        if value < HeatedRefrigeratedShippingContainer.MIN_CELSIUS:
            raise ValueError(f"Temperature {value} is out of range!")
        RefrigeratedShippingContainer.celsius.fset(self, value)

```

</span>
</details>

### Template Method Pattern

- implement skeletal operations in base classes while deferring some details to subclasses

[Template Method](/src/images/python/template-method-overview.png)

---

## Strings and Representations

### `repr()`

- built-in function
- produces unambiguous string representation of an object
- often suggested that `repr()` should return legitimate source code (i.e. can be copy/pasted and run to recreate the object)

```python
class Point2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return '({}, {})'.format(self.x, self.y)

    def __repr__(self):
        return 'Point2D(x={}, y={})'.format(self.x, self.y)

point = Point2D(x=12, y=24)
point.repr()
#=> 'Point2D(x=12, y=24)'
str(point)
#=> '(12, 24)'
```

#### Other considerations

- exactness more important than human-friendliness
- suited for debugging
- includes identifying information
- generally best for logging
- generally, result of `repr()` should contain **more information** than result of `str()`
- as a rule, should **always write** a `repr()` for your classes

### `str()`

- built-in function
- produces readable, human-friendly representation of an object
- used in situations where it might be integrated into normal text or where programming-level details might be meaningless

### `repr()` and `str()` details

- by default, `str()` calls `repr()`
    - _i.e. if `__str__` is not defined on a class but `__repr__` is, then `__repr__` will be called when `str()` is called on an instance of that class_
- however, `repr()` _does not_ call `str()`
- `repr()` is used when showing elements of a collection

### Interaction with `format()`

- `__format__()` is special class method which is invoked by `str.format()`
- simple example
```python
class MyClass:
    def __init__(self, foo, bar):
        self.foo = foo
        self.bar = bar

    def __format__(self, f): # `f` contains any special formatting options specified in original format string
        return '[Formatted representation of class: {}, {}, {}]'.format(self.foo, self.bar, f)
```
- can force the use of a class's methods:
    - force use of `__repr__()` by using `!r` in the format string: `'{!r}.format()`
    - force use of `__str__()` by using `!s` in the format string: `'{!s}.format()`

### `reprlib`

- standard library module
- supports alternative implementations of `repr()`
- often used for things like limiting how many elements of a large list is printed
- primary usage is simply `reprlib.repr()`
- [reprlib docs](https://docs.python.org/3/library/reprlib.html)

### Other built-in functions

- `ascii()`
    - takes string as argument and replaces non-ASCII characters with escape sequences
- `ord()`
    - takes single character string and converts it to **integer** Unicode codepoint
- `chr()`
    - takes single **integer** Unicode codepoint and converts it to single character string

---

## Iterables and Iteration

### Multi-Input Comprehensions

Comprehensions can use **multiple input sequences** and **multile if-clauses**

Benefits:
- container populated "atomically"
- allows Python to optimize creation
- more readable

```python
[(x, y) for x in range(5) for y in range(3)]

# above as `for` loops
points = []
for x in range(5):
    for y in range(3):
        points.append((x, y))


values = [x / (x - y)
          for x in range(100) if x > 50
          for y in range(100) if x - y != 0]

# above as `for` loops
values = []
for x in range(100):
    if x > 50:
        for y in range(100):
            if x - y != 0:
                values.append(x / (x - y))

# referencing variable from 1st `for` loop in 2nd `for` loop
[(x, y) for x in range(10) for y in range(x)]

# above as `for` loops
result = []
for x in range(100):
    for y in range(x):
        result.append((x, y))
```

### Nested Comprehensions

- all comprehensions nest in the same way

```python
vals = [[y * 3 for y in range(x)] for x in range(10)]

# above as `for` loops
outer = []
for x in range(10):
    inner = []
    for y in range(x):
        inner.append(y * 3)
    outer.append(inner)


```

### `map()`

- apply a function to every element in a sequence, producing a new sequence
- creates `map` object that uses lazy evaluation, meaning it only produces values as needed
    - `map` object is an iterator object
- can accept any number of input sequences
    - **NOTE**: number of input sequences _**must**_ match number of functional arguments
![map-with-multiple-input-sequences](../src/images/python/function-vs-lambda.png)
- map will terminate as soon as _any_ of the input sequences are terminated

```python
# get Unicode codepoint for each character in string
map(ord, 'The quick brown fox')
#=> <map object at 0x101576a90>
```

Using `Trace` with first arg of `map()`

```python
class Trace:
    def __init__(self):
        self.enabled = True

    def __call__(self, f):
        def wrap(*args, **kwargs):
            if self.enabled:
                print('Calling {}'.format(f))
            return f(*args)

result = map(Trace()(ord), 'The quick brown fox')
```

Example with multiple input-sequences:
```python
sizes = ['small', 'medium', 'large']
colors = ['lavender', 'teal', 'burnt orange']
animals = ['koala', 'platypus', 'salamander']
def combine(size, color, animal):
    return '{} {} {}'.format(size, color, animal)

list(map(combine, sizes, colors, animals))
#=> ['small lavender koala', 'medium teal platypus', 'large burnt orange salamander']
```

Example of early termination
```python
import itertools

sizes = ['small', 'medium', 'large']
colors = ['lavender', 'teal', 'burnt orange']
animals = ['koala', 'platypus', 'salamander']

def combine(quantity, size, color, animal):
    return '{} x {} {} {}'.format(quantity, size, color, animal)

list(map(combine, itertools.count(), sizes, colors, animals))
#=> ['0 x small lavender koala', '1 x medium teal platypus', '2 x large burnt orange salamander']
```

### `filter()`

- apply a function to each element in a sequence, constructing a new sequence with the elements for which the function returns `True`
- unlike `map`, only accepts single sequence and function must only accept single argument
- **NOTE**: can pass `None` as first argument to remove elements which evaluate to `False`

```python
positives = filter(lambda x: x > 0, [1, -5, 0, 6, -2, 8])
#=> <filter object at 0x101576d90>
list(positives)
#=> [1, 6, 8]
```

### `functools.reduce()`

- repeatedly apply a function to elements of a sequence, reducing them to a single value
- accepts optional **initial value**
    - _conceptually, just added to the start of the input sequence_

_NOTE: standard library `operator` module contains function equivalents of infix operators_

```python
from functools import reduce
import operator

reduce(operator.add, [1, 2, 3, 4, 5])
#=> 15
```

Example with function that prints progress
```python
from functools import reduce

def mul(x, y):
    print('mul {} {}'.format(x, y))
    return x * y

reduce(mul, range(1, 10))
#=> mul 1, 2
#=> mul 2, 3
#=> mul 6, 4
#=> mul 24, 5
#=> mul 120, 6
#=> mul 720, 7
#=> mul 5040, 8
#=> mul 40320, 9
#=> 362880


import operator

values = [1, 2, 3]
reduce(operator.add, values, 0)
#=> 6

values = []
reduce(operator.add, values, 0)
#=> 0
```

### Iteration Protocols

- `iter()`
    - create an iterator
- `next()`
    - get next element in sequence
- `StopIteration`
    - signal end of sequence

**iterable**: object that implements `__iter__()` method
**iterator**: object that implements the iterable protocol and the `__next__()` method

```python
class ExampleIterator:
    def __init__(self, data):
        self.index = 0
        self.data = data

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= len(self.data):
            raise StopIteration()

        result = self.data[self.index]
        self.index += 1
        return result

class ExampleIterable:
    def __init__(self):
        self.data = [1, 2, 3]

    def __iter__(self):
        return ExampleIterator(self.data)
```

#### Alternative Iterable Protocol

- works with any object that supports consecutive **integer indexing** via `__getitem__()`
    - when out of indexes, `__getitem__()` must throw IndexError

```python
class AlternateIterable:
    def __init__(self):
        self.data = [1, 2, 3]

    def __getitem__(self, idx):
        return self.data[idx]
```

### Extended `iter()`

- `iter(callable, sentinel)`
    - `callable`: object that takes zero args
    - `sentinel`: iteration stops when `callable` produce this value
- often used for creating **infinite sequences** from existing functions

### Real-world Usage Examples

#### Streamed Sensor Data

```python
# sensor.py
import datetime
import itertools
import random
import time

class Sensor:
    def __iter__(self):
        return self

    def __next__(self):
        return random.random()

sensor = Sensor()
timestamps = iter(datetime.datetime.now, None)

for stamp, value in itertools.islice(zip(timestamps, sensor), 10):
    print(stamp, value)
    time.sleep(1)
```

---

## Inheritance and Subtype Polymorphism

<details>

<summary>

### Realistic example: `SortedList`

</summary>

<span>

```python
class SimpleList:
    def __init__(self, items):
        self._items = list(items)

    def add(self, item):
        self._items.append(item)

    def __getitem__(self, index):
        return self._items[index]

    def sort(self):
        self._items.sort()

    def __len__(self):
        return len(self._items)

    def __repr__(self):
        return "SimpleList({!r})".format(self._items)


class SortedList(SimpleList):
    def __init__(self, items=()):  # optional sequence argument
        super().__init__(items)
        self.sort()

    def add(self, item):
        super().add(item)
        self.sort()

    def __repr__(self):
        return "SortedList({!r})".format(list(self))


class IntList(SimpleList):
    def __init__(self, items=()):
        for x in items: self._validate(x)
        super().__init__(items)

    @staticmethod
    def _validate(x):
        if not isinstance(x, int):
            raise TypeError('IntList only supports integer values.')

    def add(self, item):
        self._validate(item)
        super().add(item)

    def __repr__(self):
        return "IntList({!r})".format(list(self))


class SortedIntList(IntList, SortedList):
    def __repr__(self):
        return "SortedIntList({!r})".format(list(self))
```

</span>
</details>

Useful built-in functions:
- **`isinstance()`**
    - determines if object is of a specified type
    - will also return `True` if object is a subclass of specified type
    - second argument can also be a tuple of types
    -   ```python
        # in repl
        >>> isinstance(3, int)
        #=> True
        >>> isinstance('hello!', str)
        #=> True
        >>> x = []
        >>> isinstance(x, (float, dict, list))
        #=> True
        ```
- **`issubclass()`**
    - determines if one type is subclass of another
    -   ```python
        class BaseClass:

            def __init__(self, foo):
                self.foo = foo

        class SubClass(BaseClass):

            def __init__(self, foo, bar):
                super().__init__(foo)
                self.bar = bar

        class SubSubClass(SubClass):

            def __init__(self, foo, bar, baz):
                super().__init__(foo, bar)
                self.baz = baz

        issubclass(BaseClass, SubClass)
        #=> False
        issubclass(SubClass, BaseClass)
        #=> True
        issubclass(SubSubClass, BaseClass)
        #=> True
        ```

- **Single inheritance**
    -   ```python
        class SubClass(BaseClass):
            pass
        ```
    - **NOTE**: base class initializer will _only_ be called automatically if subclass initializer is _undefined_
- **Multiple inheritance**
    - defining class with more than one base class
    -   ```python
        class SubClass(Base1, Base2, . . .):
            pass
        ```
    - subclasses inherit methods of all bases
    - names resolve in the obvious way (_assuming there are no conflicts_)
    - **Method Resolution Order** (MRO) determines name lookup in all cases
    - if the class
        - A. has multiple base classes
        - B. defines no initializer
        then only the initializer of the first base class is automatically called
    - `__bases__` member of class objects
        - a tuple of base classes

### Method Resolution Order

- ordering that determines method name lookup
    - _more precisely: ordering of a class's inheritance graph used to determine which implementation to use when a method is invoked_
- MRO of a class determines order in which inheritance graph is searched to find the correct implementation of the method
- class's MRO is stored on `__mro__` member
    - returns tuple of classes defining method resolution order
- can also call `mro()` to get the order as a list rather than a tuple

#### How is MRO used to dispatch method calls?

When you call a method on an object in Python...

1. looks at MRO for object's type
2. for each entry in MRO (_from front to back_), check if that class has requested method
3. as soon as a class is found with matching method, that method is used and search stops

#### How is Method Resolution Order Calculated?

**C3**
    - algorithm for calculating MRO in Python
    - ensures that
        - subclasses come before base classes
        - base class order from class definition is preserved
        - first two qualities are preserved no matter where you start in the inheritance graph
    - because of the above criteria, **not all inheritance declarations are allowed!**

```python
# Example of multiple inheritance that violates C3
>>> class A:
...     pass
>>> class B(A):
...     pass
>>> class C(A):
...     pass
>>> class D(B, A, C):
...     pass
#=> TypeError: Cannot create a consistent method resolution order (MRO) for bases A, C
```
_**Explanation of above**:_
    - _since `B` and `C` both inherit from `A`, `B` and `C` must both come before `A` in any MRO_
    - _however, since `D`'s base class declaration puts `A` before `C`, **and** since C3 also guarantees that base class declaration order is preserved, C3 cannot produce a consistent MRO, as it can't put `A` **both before and after** `C`_

### Built-in `super()` Function

**Short, albeit incomplete, definition**: given a method resolution order and a class `C`, `super()` gives you an object which resolves methods using only the part of the MRO which comes after `C`

- `super()` returns a proxy object which routes method calls
    - **bound proxy**: bound to specific class or instance
    - **unbound proxy**: not bound to specific class or instance
        - _primarily an implementation detail for other Python features_

### Class-Bound Super Proxies

two types of bound proxies:
- instance-bound
- class-bound

#### Class-bound proxy

`super(base-class, derived-class)`
- `base-class` is class object
- `derived-class` is subclass of first argument
- when invoking method on proxy...
    1. finds MRO for derived-class
    2. then finds base-class in that MRO
    3. takes everything **after** base-class in MRO and finds first class in _that_ sequence with matching method name

**Explanation using [`SortedList` example](#realistic-example-SortedList)

```python
>>> from sorted_list import *
>>> from pprint import pprint as pp
>>> pp(SortedIntList.mro())
#=> [
#=>     <class 'sorted_list.SortedIntList'>,
#=>     <class 'sorted_list.IntList'>,
#=>     <class 'sorted_list.SortedList'>,
#=>     <class 'sorted_list.SimpleList'>,
#=>     <class 'object'>,
#=> ]
>>> super(SortedList, SortedIntList)
#=> <super: <class 'SortedList'>, <SortedIntList object>>
#=> --------- NAME RESOLUTION ---------
#=> 1. gets MRO for 'SortedIntList'
#=> 2. finds 'SortedList' in that MRO
#=> 3. takes everything after 'SortedList', giving us an MRO of containing just 'SimpleList' and 'object'
#=> 4. finds first class in that smaller MRO which has an 'add' method
>>> super(SortedList, SortedIntList).add
#=> <function SimpleList.add at 0x10436a050>
>>> super(SortedList, SortedIntList).add(4)
#=> TypeError: add() missing 1 required positional argument: 'item'
#   ^^^^^^^^ raised because our proxy is bound to a class, not an instance
#
#   However, we could invoke the method with our proxy if it's a static method or class method, like so:
>>> super(SortedList, SortedIntList)._validate(5)
>>> super(SortedList, SortedIntList)._validate('hello')
#=> TypeError: IntList only supports integer values.
```

### Instance-bound proxy

`super(class, instance-of-class)`
- similar to class-bound proxies except that they are instead bound to an instance of a class
- `class` is class object
- `instance-of-class` must be instance of `class` or any class derived from it
- when invoking method on proxy...
    1. finds MRO for type of second argument
    2. then finds location of first argument in that MRO
    3. uses everything **after** location from step 2 for resolving methods

```python
>>> from sorted_list import *
>>> from pprint import pprint as pp
>>> pp(SortedIntList.mro())
#=> [
#=>     <class 'sorted_list.SortedIntList'>,
#=>     <class 'sorted_list.IntList'>,
#=>     <class 'sorted_list.SortedList'>,
#=>     <class 'sorted_list.SimpleList'>,
#=>     <class 'object'>,
#=> ]
>>> sil = SortedIntList([5, 15, 10])
>>> sil
#=> SortedIntList([5, 10, 15])
>>> super(SortedList, sil)
#=> <super: <class 'SortedList'>, <SortedIntList object>>
>>> super(SortedList, sil).add(6)
>>> sil
#=> SortedIntList([5, 10, 15, 6]) --- Not quite 🙃
```

### Calling `super()` Without Arguments

When calling `super()` without arguments, Python will sort out arguments for you
- in an **instance method**:
```
super(class-of-method, self)
```
- in a **class method**:
```
super(class-of-method, class)
```

### The `object` Class

- core of Python's **object model**
- **ultimate** base class of every class
- **automatically added** as base class of every class


---

### Collections

_TODO_ 🙃


<!-- TEMPLATE

## header
_TODO_ 🙃

```python
# _TODO_ 🙃
```

---

-->
