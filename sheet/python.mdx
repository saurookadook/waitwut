---
title: "Python!"
date: "2022-07-23"
---

# Table of Contents
- [tuples](#tuples)
- [lists](#lists)
- [dicts](#dicts)

---

## tuples
```python
simple_tuple = ("Norway", 4.953, 3)
simple_tuple[0] #=> 'Norway'
simple_tuple[2] #=> 3

len(simple_tuple) #=> 3

for item in simple_tuple:
    print(item)

#=> Norway
#=> 4.953
#=> 3

simple_tuple + (338186.0, 265e9)
#=> ('Norway', 4.953, 3, 338186.0, 265000000000.0)
simple_tuple * 3
#=> ('Norway', 4.953, 3, 'Norway', 4.953, 3, 'Norway', 4.953, 3)
```

### creating tuple with single element
```python
tuple_with_one_element = (391,)
```

### creating empty tuple
```python
empty_tuple = ()
```

**NOTE**: in many cases, parentheses of literal tuples may be omitted
_(feature often used when returning multiple values from a function)_
```py
p = 1, 1, 1, 4, 6, 19
p #=> (1, 1, 1, 4, 6, 19)
```

### tuple unpacking
```python
def minmax(items):
    return min(items), max(items)

minmax([83, 33, 84, 32, 85, 31, 86])
#=> (31, 86)

lower, upper = minmax([83, 33, 84, 32, 85, 31, 86])
lower #=> 31
upper #=> 86

(a, (b, (c, d))) = (4, (3, (2, 1)))
a #=> 4
b #=> 3
c #=> 2
d #=> 1

########## NOTE: beautiful Python idiom for swapping two or more variables ##########
a = 'jelly'
b = 'bean'
a, b = b, a
### explanation
# first packs `a` and `b` on right side of assignment into tuple
# then unpacks tuple on left, reusing names `a` and `b`
```

## using tuple constructor
```python
tuple([561, 1105, 1729, 2465])
tuple("Carmichael")

# testing containment
5 in (3, 5, 17, 257, 65537) #=> True
5 not in (3, 5, 17, 257, 65537) #=> False
```

---

## lists
```python
integers = [3, 186, 4431, 74400, 1048443]
```

### slicing
```python
integers[1:3] #=> [186, 4431]
integers[1:-1] #=> [186, 4431, 74400]

### using only stop index
integers[2:] #=> [4431, 74400, 1048443]

### using only the start
integers[:2] #=> [3, 186]

### using neither (import idiom for copying a list, since it results in a new object)
integers[:] #=> [3, 186, 4431, 74400, 1048443]

integers_copy = integers
integers_copy is integers #=> True

integers_sliced_copy = integers[:]
integers_sliced_copy is integers #=> False
integers_sliced_copy == integers #=> True
```

#### copying with `slice`:
```py
s = [1, 2, 3, 4, 5]
r = s[:]
```
- new `list` object is created
- however, elements within it are references to same objects referred to by original
- if list's objects are _**mutable and modified**_, the changes will be observed in both lists

#### other ways to copy
```py
s = [3, 186, 4431, 74400, 1048443]

u = s.copy()
u is s #=> False

v = list(s)
v is s #=> False
```

**IMPORTANT**: all of above copying techniques perform _shallow copies_
- example:
```py
a = [[1, 2], [3, 4]]
b = a[:]
a is b #=> False
a == b #=> True

a[0] is b[0] #=> True

### rebinding value of first element
a[0] = [8, 9]
a #=> [8, 9]
b #=> [1, 2]

### mutating object at second element
a[1].append(5)
a[1] #=> [3, 4, 5]
b[1] #=> [3, 4, 5]

# final state of each list
a #=> [[8, 9], [3, 4, 5]]
b #=> [[1, 2], [3, 4, 5]]
```

_Note: for making deep copies, look to use `copy` module in Python standard library_

---

## dicts
```python
basic_dict = dict(foo='bar', baz='beep')
'foo' in basic_dict #=> True
del basic_dict['foo']
```

### pretty-printing using `pprint` module from Python standard library
```python
from pprint import pprint as pp
pp(basic_dict)
```


---

## Those other things that are good to know
- `==` tests "value equality"
- `is` tests "identity equality"
